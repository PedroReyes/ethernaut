// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import "hardhat/console.sol";

contract Privacy {
    bool public locked = true; // -------------------------------------- index 0 - 256 bits - 0x0000000000000000000000000000000000000000000000000000000000000001
    uint256 public ID = block.timestamp; // ---------------------------- index 1 - 256 bits - dynamic
    uint8 private flattening = 10; // ---------------------------------- index 2 - 8 bits   - 256 - 8 = 248
    uint8 private denomination = 255; // ------------------------------- index 2 - 8 bits   - 248 - 8 = 240
    uint16 private awkwardness = uint16(block.timestamp); // ----------- index 2 - 16 bits  - 248 - 16 = 224
    uint64 private awkwardness64_0 = uint64(1); // --------------------- index 2 - 32 bits  - 224 - 64 = 160
    uint64 private awkwardness64_1 = uint64(1); // --------------------- index 2 - 32 bits  - 160 - 64 = 96
    uint64 private awkwardness64_2 = uint64(1); // --------------------- index 2 - 32 bits  - 96 - 64 = 32
    uint32 private awkwardness32_0 = uint32(1); // --------------------- index 2 - 32 bits  - 32 - 32 = 0
    // uint32 private awkwardness32_1 = uint32(1); // ------------------ index ? - 32 bits  - up to 256 bits . . .
    bytes32[3] private data; // ---------------------------------------- index 3, 4 & 5

    // ----------------------------------------------------------------- index 3: 0x3100000000000000000000000000000000000000000000000000000000000000
    // ----------------------------------------------------------------- index 4: 0x3200000000000000000000000000000000000000000000000000000000000000
    // ----------------------------------------------------------------- index 5: 0x70617373776f7264313233000000000000000000000000000000000000000000

    constructor(bytes32[3] memory _data) {
        data = _data;
    }

    // This level is quite similar to the Vault.sol level. Same concepts apply
    function unlock(bytes16 _key) public {
        require(_key == bytes16(data[2]));
        locked = false;
    }

    /*
    A bunch of super advanced solidity algorithms...

      ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`
      .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,
      *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^         ,---/V\
      `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.    ~|__(o.o)
      ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'  UU  UU

       ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`
      .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,
      *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^         ,---/V\
      `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.    ~|__(o.o)
      ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'  UU  UU

       ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`
      .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,
      *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^         ,---/V\
      `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.    ~|__(o.o)
      ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'  UU  UU
  */

    function conversion(bytes32 _data) public pure returns (bytes16) {
        return bytes16(_data);
    }
}
